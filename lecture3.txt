lapply: loop over a list and evaluate a function on each element of the list
sapply: same as lapply but try to simplity the result
apply: apply a function over the margins of an array
tapply: apply a function over subsets of a vector (table apply)
mapply: multivariate version of lapply

An auxiliary function: split is also useful, particularly in conjunction with lapply//sapply

lapply( x, FUN, ...)

is.vector
is.null
is.integer
...

x is a list,
FUN is a function,
... is ... parameters


# lapply always return a list

x<-list(a=1:5, b=rnorm(10))
lapply(x,mean)

x<-1:4
lapply(x, runif)
lapply(x, runif, min=0, max =10)

x<- list(a = matrix(1:4, 2,2), b=matrix(1:6, 3,2))
lapply(x, function(elt) elt[,1])
lapply(x, function(elt) {elt[,1]} )

# sapply: simplify lapply's result.  
#if result is a list where every element is a vector of length 1, return a vector
#if result is a list which every element is a vector of same length>1, return a matrix
#otherwise, return a list

x<- list(a = 1:4, b=rnorm(10), c=rnorm(20,1), d=rnorm(100,50))
sapply(x, mean)


#apply: apply to margins of array
# used to apply a function to the rows or columns of a matrix, same speed as loop but in one line
str(apply)
# x is array, Margin is in integer vector indicating which margin should be retained; fun is the funtion

x<- matrix(rnorm(200), 20,10)
x
apply(x,2,mean) # keep the 2nd dimension, callapse the 1st diemnsion
apply(x,1,mean)

rowSums = apply(x, 1, sum)
rowMeanss = apply(x, 1, mean)


x<-matrix(rnorm(200), 20,10, )
apply(x,1,quantile, probs = c(0.25,0.75)) # rpobs is the ... parameters for quantile


a<-array(rnorm(2*2*10), c(2,2,10))
apply(a,c(1,2),mean) # keep the 1st, 2nd dimension, collapse the 3rd


